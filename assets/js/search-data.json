{
  
    
        "post0": {
            "title": "(R) tidy data",
            "content": "library(&#39;tidyverse&#39;) . pivot . table4a %&gt;% pivot_longer(c(&#39;1999&#39;, &#39;2000&#39;), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) . A tibble: 6 × 3 countryyearcases . &lt;chr&gt;&lt;chr&gt;&lt;int&gt; . Afghanistan | 1999 | 745 | . Afghanistan | 2000 | 2666 | . Brazil | 1999 | 37737 | . Brazil | 2000 | 80488 | . China | 1999 | 212258 | . China | 2000 | 213766 | . table4a %&gt;% pivot_longer(c(&#39;1999&#39;,&#39;2000&#39;), names_to = &#39;year&#39;, values_to = &#39;population&#39;) . A tibble: 6 × 3 countryyearpopulation . &lt;chr&gt;&lt;chr&gt;&lt;int&gt; . Afghanistan | 1999 | 745 | . Afghanistan | 2000 | 2666 | . Brazil | 1999 | 37737 | . Brazil | 2000 | 80488 | . China | 1999 | 212258 | . China | 2000 | 213766 | . table4a . A tibble: 3 × 3 country19992000 . &lt;chr&gt;&lt;int&gt;&lt;int&gt; . 1Afghanistan | 745 | 2666 | . 2Brazil | 37737 | 80488 | . 3China | 212258 | 213766 | . tidy4a &lt;- table4a %&gt;% pivot_longer(c(&#39;1999&#39;, &#39;2000&#39;), names_to = &#39;year&#39;, values_to = &#39;cases&#39;) tidy4b &lt;- table4b %&gt;% pivot_longer(c(&#39;1999&#39;, &#39;2000&#39;), names_to = &#39;year&#39;, values_to = &#39;population&#39;) left_join(tidy4a, tidy4b) . Joining, by = c(&#34;country&#34;, &#34;year&#34;) . A tibble: 6 × 4 countryyearcasespopulation . &lt;chr&gt;&lt;chr&gt;&lt;int&gt;&lt;int&gt; . Afghanistan | 1999 | 745 | 19987071 | . Afghanistan | 2000 | 2666 | 20595360 | . Brazil | 1999 | 37737 | 172006362 | . Brazil | 2000 | 80488 | 174504898 | . China | 1999 | 212258 | 1272915272 | . China | 2000 | 213766 | 1280428583 | .",
            "url": "https://jjyun98.github.io/main/2022/07/22/_tidydata.html",
            "relUrl": "/2022/07/22/_tidydata.html",
            "date": " • Jul 22, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "tibble, parsing [R]",
            "content": "library(&#39;tidyverse&#39;) . - 데이터프레임을 티블로 변형하기 . as_tibble(iris) %&gt;% head . A tibble: 6 × 5 Sepal.LengthSepal.WidthPetal.LengthPetal.WidthSpecies . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;fct&gt; . 5.1 | 3.5 | 1.4 | 0.2 | setosa | . 4.9 | 3.0 | 1.4 | 0.2 | setosa | . 4.7 | 3.2 | 1.3 | 0.2 | setosa | . 4.6 | 3.1 | 1.5 | 0.2 | setosa | . 5.0 | 3.6 | 1.4 | 0.2 | setosa | . 5.4 | 3.9 | 1.7 | 0.4 | setosa | . tibble( x = 1:5, y = 1, z = x^2 + y ) . A tibble: 5 × 3 xyz . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt; . 1 | 1 | 2 | . 2 | 1 | 5 | . 3 | 1 | 10 | . 4 | 1 | 17 | . 5 | 1 | 26 | . tibble과 데이터프레임의 차이점 1) 입력 유형을 절대로 변경하지 않는다 ex) 문자열 &gt; factor 2) 변수의 이름을 바꾸거나 행 이름을 생성하지 않는다 3) 티블은 R변수명으로 유효하지 않은 이름도 열 이름으로 가질 수 있다 ex) 공백다만, 이런 변수들을 참조하려면 역따옴표(`)로 감싸야한다고 하는데 안써도 되는데? . tb &lt;- tibble( `apple` = &quot;근본&quot;, &#39; &#39; = &quot;스페이스&quot;, &#39;1000&#39; = &quot;숫자&quot;) . tb . A tibble: 1 × 3 apple 1000 . &lt;chr&gt;&lt;chr&gt;&lt;chr&gt; . 근본 | 스페이스 | 숫자 | . tribble . 티블을 만드는 또 다른 방법(적은 양의 데이터를 빠르게 읽기 쉬운형태로 만드는) 열 헤더는 공식으로 정의(~로 시작), 입력은 쉼표로 구분) . tribble( ~x, ~y, ~z, &quot;c&quot; , 3, 4.0, &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) . A tibble: 3 × 3 xyz . &lt;chr&gt;&lt;dbl&gt;&lt;dbl&gt; . c | 3 | 4.0 | . a | 2 | 3.6 | . b | 1 | 8.5 | . tibble( a = lubridate::now() + runif(1e3) * 86400, b = lubridate::today() + runif(1e3) * 30, c = 1:1e3, d = runif(1e3), e = sample(letters, 1e3, replace = TRUE) ) %&gt;% head . A tibble: 6 × 5 abcde . &lt;dttm&gt;&lt;date&gt;&lt;int&gt;&lt;dbl&gt;&lt;chr&gt; . 2022-07-23 18:36:53 | 2022-07-28 | 1 | 0.00343761 | k | . 2022-07-23 13:49:37 | 2022-07-22 | 2 | 0.45199147 | h | . 2022-07-22 21:11:33 | 2022-08-11 | 3 | 0.07705210 | i | . 2022-07-22 22:44:18 | 2022-07-22 | 4 | 0.01277533 | w | . 2022-07-23 03:04:22 | 2022-08-07 | 5 | 0.54975539 | w | . 2022-07-23 02:53:20 | 2022-08-20 | 6 | 0.06460381 | o | . 참고) 1e3 = 1000이다 | . runif : 평균=0, 표준편차=1의 무작위 난수 추출 . print(n=) : 보여주는 행의수 제어 width = Inf : 열 모두 보이기 . nycflights13::flights %&gt;% print(n = 10, width = Inf) . # A tibble: 336,776 × 19 year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour minute &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 7 19 B6 507 N516JB EWR FLL 158 1065 6 0 8 -14 EV 5708 N829AS LGA IAD 53 229 6 0 9 -8 B6 79 N593JB JFK MCO 140 944 6 0 10 8 AA 301 N3ALAA LGA ORD 138 733 6 0 time_hour &lt;dttm&gt; 1 2013-01-01 05:00:00 2 2013-01-01 05:00:00 3 2013-01-01 05:00:00 4 2013-01-01 05:00:00 5 2013-01-01 06:00:00 6 2013-01-01 05:00:00 7 2013-01-01 06:00:00 8 2013-01-01 06:00:00 9 2013-01-01 06:00:00 10 2013-01-01 06:00:00 # … with 336,766 more rows . &#49436;&#48652;&#49483; . df &lt;- tibble( x = runif(5), y = rnorm(5) ) df . A tibble: 5 × 2 xy . &lt;dbl&gt;&lt;dbl&gt; . 0.9973514 | -1.1163051 | . 0.2167404 | 0.6167982 | . 0.5017351 | -0.7638092 | . 0.4860576 | -0.2532930 | . 0.3348231 | -0.9161202 | . df$x . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; df[[&quot;x&quot;]] . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; df[[1]] . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; - pipe에서의 서브셋 . 찍어줘야한다 . df %&gt;% .$x . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; df %&gt;% .[[&quot;x&quot;]] . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; - 일부 오래된 함수의 경우 tibble에서 동작하지 않기에 이 경우 dataframe으로 변환후 사용한다 . class(as.data.frame(tb)) . &#39;data.frame&#39; read_csv . option만 넣음 | . skip = n : 첫 n줄 건너 뛰기 comment = # : #으로 시작하는 모든 줄 무시 col_names = FALSE : 첫 행을 헤드로 취급하지 않고 x1 ~ xn으로 이름 붙임(데이터에 열 이름 없을 때 사용) . parsing . (뜻)parse -&gt; 분석하다 | . parse_무언가() : 문자형 벡터를 입력으로 하여 논리형, 정수형 또는 날짜형과 같은 좀 더 특수화된 벡터를 반환 . - parsing 실패 . 실패하면 경고문과 함께 NA로 표기 이 경우 problems()사용하면 문제점 알려줌 . x &lt;- parse_integer(c(&quot;123&quot;,&quot;345&quot;,&quot;abc&quot;,&quot;123.45&quot;)) . Warning message: “2 parsing failures. row col expected actual 3 -- no trailing characters abc 4 -- no trailing characters 123.45 ” . x . &lt;ol class=list-inline&gt;123 | 345 | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; problems(x) . A tibble: 2 × 4 rowcolexpectedactual . &lt;int&gt;&lt;int&gt;&lt;chr&gt;&lt;chr&gt; . 3 | NA | no trailing characters | abc | . 4 | NA | no trailing characters | 123.45 | . parse 종류 . parse_logical :논리형 parse_integer : 정수형 parse_double : 엄격한 수치형(★★★) parse_number : 유연한 수치형(★★) -&gt; 각자 다른 방식의 숫자 표현을 써버리기에 parse_character : 문자형 -&gt; 단순하지만 문자 인코딩에서 중요 parse_factor : 팩터형(R이 미리 정해지고 알려진 값으로 범주형 변수를 나타내기 위해 사용하는 데이터 구조) parse_datetime : 날짜/시각(★★★★) -&gt; 날짜를 쓰는 방법은 다양하기에 이들이 제일 복잡 parse_date : 날짜/시각(★★★★) parse_time : 날짜/시각(★★★★) . &#49707;&#51088; parsing . 숫자 파싱이 문제가 되는 3가지 1) 소수점 구별기호 ex) . or , 2) 단위 ex) $ % 3) 간혹 읽기 편하라고 &#39; &#39; 사용 . - 첫 번째 문제 해결 지역에 따라 파싱 옵션을 지정하는 객체인 locale사용 변경이 필요할 경우 새로운 locale을 생성하고 decimal_mark인수를 설정하여 기본값인 .을 다른 값으로 재정의 . parse_double(&quot;1.23&quot;) . 1.23 - 변경 예시 . parse_double(&quot;1,23&quot;, locale = locale(decimal_mark = &quot;,&quot;)) . 1.23 -두 번째 문제 해결 parse_number는 숫자 앞뒤의 비수치 문자(non-numeric character)를 모두 무시 통화 및 백분율에 특히 유용하고 텍스트에 포함된 숫자를 추출하는 데도 효과적 . parse_number(&quot;$100&quot;) . 100 parse_number(&quot;20%&quot;) . 20 - 비수치 문자 무시 예 . parse_number(&quot;It cost $123.45&quot;) . 123.45 - 미국식 처리법 . parse_number(&quot;$123,456,789&quot;) . 123456789 - 유럽식 처리법 . parse_number( &quot;123.456.789&quot;, locale = locale(grouping_mark = &quot;.&quot;)) . 123456789 - factor형 처리 R은 팩터형을 사용하기에, 가질 수 있는 값을 미리 알고 있는 범주형 변수를 나타낸다 . fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;) parse_factor(c(&quot;apple&quot;, &quot;banana&quot;, &quot;bananana&quot;), levels = fruit) . Warning message: “1 parsing failure. row col expected actual 3 -- value in level set bananana ” . &lt;ol class=list-inline&gt;apple | banana | &lt;NA&gt; | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt;&#39;apple&#39; | &#39;banana&#39; | &lt;/ol&gt; &#45216;&#51676; parsing . parse_datetime(&quot;2010-10-01T2010&quot;) . [1] &#34;2010-10-01 20:10:00 UTC&#34; . parse_datetime(&quot;20101010&quot;) . [1] &#34;2010-10-10 UTC&#34; . parse_date(&quot;2010-10-01&quot;) . 2010-10-01 library(&#39;hms&#39;)# 시간 데이터 다루는 패키지 . parse_time(&quot;20:10:01&quot;) . 20:10:01 . parse_time(&quot;01:10 am&quot;) . 01:10:00 . 위의 예시들로 주어진 데이터를 처리하지 못한다면 나만의 format을 만들어 사용가능 연 %Y(4 자리) %y(2 자리, 00-69 -&gt; 2000-2069, 70-99 -&gt; 1970-1999) 월 %m(2 자리) %b(&quot;jan&quot;과 같이 축약된 명칭) %B(전체 명칭, &quot;January&quot;) 일 %d(2 자리) %e(선택적 선행 공백) 시간 %H(0-23 시간 형식) %I(0-12, %p와 함께 사용해야 함) %p(a.m/p.m표시) %M(분) %S(정수 초) %OS(실수 초) 숫자가 아닌 문자 %.(숫자가 아닌 문자 하나를 건너뛴다) %*(숫자가 아닌 문자 모두를 건너뛴다) . - 시간 데이터 처리 예시 . parse_date(&quot;01/02/15&quot;, &quot;%m/%d/%y&quot;) . 2015-01-02 parse_date(&quot;01/02/15&quot;, &quot;%d/%m/%y&quot;) . 2015-02-01 parse_date(&quot;01/02/15&quot;, &quot;%y/%m/%d&quot;) . 2001-02-15",
            "url": "https://jjyun98.github.io/main/2022/07/22/_tibble_%ED%95%99%EC%8A%B5.html",
            "relUrl": "/2022/07/22/_tibble_%ED%95%99%EC%8A%B5.html",
            "date": " • Jul 22, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "R ggplot",
            "content": "1&#51109; ggplot . library(&#39;tidyverse&#39;) . color . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y= hwy, color = class)) . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y= hwy, size = class)) . Warning message: “Using size for a discrete variable is not advised.” . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y = hwy, alpha = class)) . Warning message: “Using alpha for a discrete variable is not advised.” . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y = hwy, shape = class)) . Warning message: “The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7. Consider specifying shapes manually if you must have them.” Warning message: “Removed 62 rows containing missing values (geom_point).” . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y= hwy), color = &#39;blue&#39;) . facet_wrap . - 차 종류(class)에 따라 나눈 모습 nrow = 줄 개수 . ggplot(data = mpg) + geom_point(mapping = aes(x=displ, y=hwy)) + facet_wrap(~ class, nrow = 3) . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y= hwy)) + facet_grid(drv ~ cyl) . # ![Image](IMG_0393.jpg) . 깃헙 이미지는 올리법 따로 있음 그거 이용 . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y= hwy),shape =23) . facet_grid . facet grid에 적은 항목들의 결과 plot 보여줌 . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y =hwy)) + facet_grid(drv ~ cyl) . mpg %&gt;% head . A tibble: 6 × 11 manufacturermodeldisplyearcyltransdrvctyhwyflclass . &lt;chr&gt;&lt;chr&gt;&lt;dbl&gt;&lt;int&gt;&lt;int&gt;&lt;chr&gt;&lt;chr&gt;&lt;int&gt;&lt;int&gt;&lt;chr&gt;&lt;chr&gt; . audi | a4 | 1.8 | 1999 | 4 | auto(l5) | f | 18 | 29 | p | compact | . audi | a4 | 1.8 | 1999 | 4 | manual(m5) | f | 21 | 29 | p | compact | . audi | a4 | 2.0 | 2008 | 4 | manual(m6) | f | 20 | 31 | p | compact | . audi | a4 | 2.0 | 2008 | 4 | auto(av) | f | 21 | 30 | p | compact | . audi | a4 | 2.8 | 1999 | 6 | auto(l5) | f | 16 | 26 | p | compact | . audi | a4 | 2.8 | 1999 | 6 | manual(m5) | f | 18 | 26 | p | compact | . mpg$drv %&gt;% unique() . &lt;ol class=list-inline&gt;&#39;f&#39; | &#39;4&#39; | &#39;r&#39; | &lt;/ol&gt; mpg$cyl %&gt;% unique() . &lt;ol class=list-inline&gt;4 | 6 | 8 | 5 | &lt;/ol&gt; 열이나 행으로 면분할 하고싶지 않다면 변수이름 대신 . 사용 . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y =hwy)) + facet_grid(. ~ cyl) . cyl에 대한 내용만 나옴 . ggplot(data = mpg) + geom_point(mapping = aes(x= displ, y = hwy)) . geom_smooth . ggplot(data = mpg)+ geom_smooth(mapping = aes(x=displ, y= hwy)) . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . 데이터에 적합된 평활선 . line자체의 shape은 선택 불가지만 line type 선택 해줄 수 있음 . ggplot(data = mpg)+ geom_smooth(mapping = aes(x=displ, y=hwy, linetype = drv)) . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . 색깔 입히기 가능 . ggplot(data = mpg)+ geom_smooth(mapping = aes(x=displ, y=hwy, group = drv)) . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . ggplot(data = mpg)+ geom_smooth(mapping = aes(x=displ, y=hwy, color = drv)) . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . 다 합쳐서 그리기 . ggplot(data = mpg)+ geom_point(mapping = aes(x=displ, y=hwy,color = drv))+ geom_smooth(mapping = aes(x=displ, y=hwy, color = drv, linetype = drv)) . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . &#53076;&#46300; &#51473;&#48373; &#54588;&#54616;&#44592; . ggplot안에 mapping 해 놓으면 다음번에 안써도 된다 . ggplot(data = mpg, mapping = aes(x= displ, y=hwy)) + geom_point() + geom_smooth() . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . mapping 해놓고 옵션추가 하고 싶다면 해당 geom에 가서 그 부분만 mapping하고 옵션주면 됨. . ggplot(data = mpg, mapping = aes(x= displ, y=hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth() . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . filter &#49324;&#50857; . 해당 레이어에 한해서만 smooth 하기위해 filter 사용 se = FALSE하면 그림자 꺼짐 . ggplot(data = mpg, mapping = aes(x= displ, y=hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth( data = filter(mpg, class == &#39;subcompact&#39;), se= FALSE ) . `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; . ggplot(data = diamonds) + geom_bar(mapping = aes(x= cut)) . ggplot(data = diamonds)+ stat_count(mapping = aes(x=cut)) . 이것을 보면 geom_bar의 y축의 default값이 stat_count임을 알 수 있다 이 stat을 다른 값을 주면 y축 종류를 바꿀 수 있음 . demo &lt;- tribble( ~cut, ~freq, &quot;Fair&quot;, 1610, &quot;Good&quot;, 4906, &quot;Very Good&quot;, 12082, &quot;Premium&quot;, 13791, &quot;Ideal&quot;, 21551 ) . demo . A tibble: 5 × 2 cutfreq . &lt;chr&gt;&lt;dbl&gt; . Fair | 1610 | . Good | 4906 | . Very Good | 12082 | . Premium | 13791 | . Ideal | 21551 | . ggplot(data = demo) + geom_bar(mapping = aes(x= cut,y=freq), stat = &#39;identity&#39;) . 비율로 표시하기 . ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = stat(prop), group =1) ) . stat_summary로 표현 . ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y= depth), fun.ymin = min, fun.ymax = max, fun.y = median ) . Warning message: “`fun.y` is deprecated. Use `fun` instead.” Warning message: “`fun.ymin` is deprecated. Use `fun.min` instead.” Warning message: “`fun.ymax` is deprecated. Use `fun.max` instead.” . geom_bar에서 color 사용시 막대그래프의 테두리 색 선택 geom_bar에서 fill 사용시 막대그래프 자체 색 선택 . ggplot(data = diamonds) + geom_bar(mapping = aes(x= cut, color = cut)) ggplot(data = diamonds) + geom_bar(mapping = aes(x= cut, fill = cut)) . - 다른 변수 추가해서 각각 얼마나 차지하는지 보이기 . ggplot(data = diamonds) + geom_bar(mapping = aes(x= cut, fill = clarity)) . diamonds$clarity %&gt;% unique . &lt;ol class=list-inline&gt;SI2 | SI1 | VS1 | VS2 | VVS2 | VVS1 | I1 | IF | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt;&#39;I1&#39; | &#39;SI2&#39; | &#39;SI1&#39; | &#39;VS2&#39; | &#39;VS1&#39; | &#39;VVS2&#39; | &#39;VVS1&#39; | &#39;IF&#39; | &lt;/ol&gt; position = &#39;identity&#39; : 각 객체를 그래프 문맥에 해당되는 곳에 정확히 배치한다. 다만, 막대그래프에서는 그리 유용하지 않음 . ggplot( data = diamonds, mapping = aes(x = cut, fill = clarity) )+ geom_bar(alpha = 0.3, position = &#39;identity&#39;) . 테두리만 색입히고 막대를 빈공간으로 만드는 것도 가능 . ggplot( data = diamonds, mapping = aes(x = cut, color = clarity) )+ geom_bar(fill = NA, position = &#39;identity&#39;) . position = &#39;fill&#39; : 누적 막대인데 막대 높이를 동일하게 맞춤 비율 비교에 용이 . ggplot(data = diamonds) + geom_bar( mapping = aes(x =cut, fill = clarity), position = &#39;fill&#39; ) . position = &#39;dodge&#39; : 옆으로 쌓기 개별 값들의 비교 용이 . ggplot(data = diamonds) + geom_bar( mapping = aes(x =cut, fill = clarity), position = &#39;dodge&#39; ) . position = &#39;jitter&#39; : 중복된 값 진하게 표시 . ggplot(data = mpg) + geom_point( mapping = aes(x =displ, y=hwy), position = &#39;jitter&#39; ) . coord_flip() : x축 y축 변경 . ggplot(data = mpg, mapping = aes(x = class, y= hwy)) + geom_boxplot() ggplot(data = mpg, mapping = aes(x = class, y= hwy)) + geom_boxplot() + coord_flip() . maps : 위도, 경도 가져오는 library . library(&#39;maps&#39;) . 다음의 패키지를 부착합니다: ‘maps’ The following object is masked from ‘package:purrr’: map . nz &lt;- map_data(&#39;nz&#39;) . nz %&gt;% head . A data.frame: 6 × 6 longlatgrouporderregionsubregion . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;int&gt;&lt;chr&gt;&lt;chr&gt; . 1172.7433 | -34.44215 | 1 | 1 | North.Island | NA | . 2172.7983 | -34.45562 | 1 | 2 | North.Island | NA | . 3172.8528 | -34.44846 | 1 | 3 | North.Island | NA | . 4172.8986 | -34.41786 | 1 | 4 | North.Island | NA | . 5172.9593 | -34.42503 | 1 | 5 | North.Island | NA | . 6173.0184 | -34.39895 | 1 | 6 | North.Island | NA | . ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &#39;white&#39;, color = &#39;black&#39;) . coord_quickmap() : 지도에 맞게 가로세로 비율 설정 공간 데이터 plot에서 중요 . ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &#39;white&#39;, color = &#39;black&#39;) + coord_quickmap() . labs : NULL하면 x축이나 y축 이름 안보이게 함 theme(aspect.ratio) : 1이면 정사각형 모양, 그 이상은 세로 길어짐, 이하는 가로가 길어짐 width : 막대 뚱뚱한 정도 show.legend : 범주 표기 여부 . bar &lt;- ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1 ) + theme(aspect.ratio = 1)+ labs(x = NULL, y = NULL) bar + coord_flip() . coord_polar() : pie 차트로 변경 . bar + coord_polar() . 2&#51109; . this . Error in eval(expr, envir, enclos): 객체 &#39;this&#39;를 찾을 수 없습니다 Traceback: .",
            "url": "https://jjyun98.github.io/main/2022/07/22/_ggplot_%ED%95%99%EC%8A%B5.html",
            "relUrl": "/2022/07/22/_ggplot_%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8.html",
            "date": " • Jul 22, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jjyun98.github.io/main/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jjyun98.github.io/main/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}