{
  
    
        "post0": {
            "title": "(R) tidy data",
            "content": "library(&#39;tidyverse&#39;) . pivot . table4a %&gt;% pivot_longer(c(&#39;1999&#39;, &#39;2000&#39;), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) . A tibble: 6 × 3 countryyearcases . &lt;chr&gt;&lt;chr&gt;&lt;int&gt; . Afghanistan | 1999 | 745 | . Afghanistan | 2000 | 2666 | . Brazil | 1999 | 37737 | . Brazil | 2000 | 80488 | . China | 1999 | 212258 | . China | 2000 | 213766 | . table4a %&gt;% pivot_longer(c(&#39;1999&#39;,&#39;2000&#39;), names_to = &#39;year&#39;, values_to = &#39;population&#39;) . A tibble: 6 × 3 countryyearpopulation . &lt;chr&gt;&lt;chr&gt;&lt;int&gt; . Afghanistan | 1999 | 745 | . Afghanistan | 2000 | 2666 | . Brazil | 1999 | 37737 | . Brazil | 2000 | 80488 | . China | 1999 | 212258 | . China | 2000 | 213766 | . table4a . A tibble: 3 × 3 country19992000 . &lt;chr&gt;&lt;int&gt;&lt;int&gt; . 1Afghanistan | 745 | 2666 | . 2Brazil | 37737 | 80488 | . 3China | 212258 | 213766 | . tidy4a &lt;- table4a %&gt;% pivot_longer(c(&#39;1999&#39;, &#39;2000&#39;), names_to = &#39;year&#39;, values_to = &#39;cases&#39;) tidy4b &lt;- table4b %&gt;% pivot_longer(c(&#39;1999&#39;, &#39;2000&#39;), names_to = &#39;year&#39;, values_to = &#39;population&#39;) left_join(tidy4a, tidy4b) . Joining, by = c(&#34;country&#34;, &#34;year&#34;) . A tibble: 6 × 4 countryyearcasespopulation . &lt;chr&gt;&lt;chr&gt;&lt;int&gt;&lt;int&gt; . Afghanistan | 1999 | 745 | 19987071 | . Afghanistan | 2000 | 2666 | 20595360 | . Brazil | 1999 | 37737 | 172006362 | . Brazil | 2000 | 80488 | 174504898 | . China | 1999 | 212258 | 1272915272 | . China | 2000 | 213766 | 1280428583 | .",
            "url": "https://jjyun98.github.io/main/2022/07/22/_tidydata.html",
            "relUrl": "/2022/07/22/_tidydata.html",
            "date": " • Jul 22, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "tibble, parsing [R]",
            "content": "library(&#39;tidyverse&#39;) . - 데이터프레임을 티블로 변형하기 . as_tibble(iris) %&gt;% head . A tibble: 6 × 5 Sepal.LengthSepal.WidthPetal.LengthPetal.WidthSpecies . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;fct&gt; . 5.1 | 3.5 | 1.4 | 0.2 | setosa | . 4.9 | 3.0 | 1.4 | 0.2 | setosa | . 4.7 | 3.2 | 1.3 | 0.2 | setosa | . 4.6 | 3.1 | 1.5 | 0.2 | setosa | . 5.0 | 3.6 | 1.4 | 0.2 | setosa | . 5.4 | 3.9 | 1.7 | 0.4 | setosa | . tibble( x = 1:5, y = 1, z = x^2 + y ) . A tibble: 5 × 3 xyz . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt; . 1 | 1 | 2 | . 2 | 1 | 5 | . 3 | 1 | 10 | . 4 | 1 | 17 | . 5 | 1 | 26 | . tibble과 데이터프레임의 차이점 1) 입력 유형을 절대로 변경하지 않는다 ex) 문자열 &gt; factor 2) 변수의 이름을 바꾸거나 행 이름을 생성하지 않는다 3) 티블은 R변수명으로 유효하지 않은 이름도 열 이름으로 가질 수 있다 ex) 공백다만, 이런 변수들을 참조하려면 역따옴표(`)로 감싸야한다고 하는데 안써도 되는데? . tb &lt;- tibble( `apple` = &quot;근본&quot;, &#39; &#39; = &quot;스페이스&quot;, &#39;1000&#39; = &quot;숫자&quot;) . tb . A tibble: 1 × 3 apple 1000 . &lt;chr&gt;&lt;chr&gt;&lt;chr&gt; . 근본 | 스페이스 | 숫자 | . tribble . 티블을 만드는 또 다른 방법(적은 양의 데이터를 빠르게 읽기 쉬운형태로 만드는) 열 헤더는 공식으로 정의(~로 시작), 입력은 쉼표로 구분) . tribble( ~x, ~y, ~z, &quot;c&quot; , 3, 4.0, &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) . A tibble: 3 × 3 xyz . &lt;chr&gt;&lt;dbl&gt;&lt;dbl&gt; . c | 3 | 4.0 | . a | 2 | 3.6 | . b | 1 | 8.5 | . tibble( a = lubridate::now() + runif(1e3) * 86400, b = lubridate::today() + runif(1e3) * 30, c = 1:1e3, d = runif(1e3), e = sample(letters, 1e3, replace = TRUE) ) %&gt;% head . A tibble: 6 × 5 abcde . &lt;dttm&gt;&lt;date&gt;&lt;int&gt;&lt;dbl&gt;&lt;chr&gt; . 2022-07-23 18:36:53 | 2022-07-28 | 1 | 0.00343761 | k | . 2022-07-23 13:49:37 | 2022-07-22 | 2 | 0.45199147 | h | . 2022-07-22 21:11:33 | 2022-08-11 | 3 | 0.07705210 | i | . 2022-07-22 22:44:18 | 2022-07-22 | 4 | 0.01277533 | w | . 2022-07-23 03:04:22 | 2022-08-07 | 5 | 0.54975539 | w | . 2022-07-23 02:53:20 | 2022-08-20 | 6 | 0.06460381 | o | . 참고) 1e3 = 1000이다 | . runif : 평균=0, 표준편차=1의 무작위 난수 추출 . print(n=) : 보여주는 행의수 제어 width = Inf : 열 모두 보이기 . nycflights13::flights %&gt;% print(n = 10, width = Inf) . # A tibble: 336,776 × 19 year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 2013 1 1 517 515 2 830 819 2 2013 1 1 533 529 4 850 830 3 2013 1 1 542 540 2 923 850 4 2013 1 1 544 545 -1 1004 1022 5 2013 1 1 554 600 -6 812 837 6 2013 1 1 554 558 -4 740 728 7 2013 1 1 555 600 -5 913 854 8 2013 1 1 557 600 -3 709 723 9 2013 1 1 557 600 -3 838 846 10 2013 1 1 558 600 -2 753 745 arr_delay carrier flight tailnum origin dest air_time distance hour minute &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 7 19 B6 507 N516JB EWR FLL 158 1065 6 0 8 -14 EV 5708 N829AS LGA IAD 53 229 6 0 9 -8 B6 79 N593JB JFK MCO 140 944 6 0 10 8 AA 301 N3ALAA LGA ORD 138 733 6 0 time_hour &lt;dttm&gt; 1 2013-01-01 05:00:00 2 2013-01-01 05:00:00 3 2013-01-01 05:00:00 4 2013-01-01 05:00:00 5 2013-01-01 06:00:00 6 2013-01-01 05:00:00 7 2013-01-01 06:00:00 8 2013-01-01 06:00:00 9 2013-01-01 06:00:00 10 2013-01-01 06:00:00 # … with 336,766 more rows . &#49436;&#48652;&#49483; . df &lt;- tibble( x = runif(5), y = rnorm(5) ) df . A tibble: 5 × 2 xy . &lt;dbl&gt;&lt;dbl&gt; . 0.9973514 | -1.1163051 | . 0.2167404 | 0.6167982 | . 0.5017351 | -0.7638092 | . 0.4860576 | -0.2532930 | . 0.3348231 | -0.9161202 | . df$x . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; df[[&quot;x&quot;]] . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; df[[1]] . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; - pipe에서의 서브셋 . 찍어줘야한다 . df %&gt;% .$x . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; df %&gt;% .[[&quot;x&quot;]] . &lt;ol class=list-inline&gt;0.997351404977962 | 0.21674042288214 | 0.501735110534355 | 0.486057616304606 | 0.33482308103703 | &lt;/ol&gt; - 일부 오래된 함수의 경우 tibble에서 동작하지 않기에 이 경우 dataframe으로 변환후 사용한다 . class(as.data.frame(tb)) . &#39;data.frame&#39; read_csv . option만 넣음 | . skip = n : 첫 n줄 건너 뛰기 comment = # : #으로 시작하는 모든 줄 무시 col_names = FALSE : 첫 행을 헤드로 취급하지 않고 x1 ~ xn으로 이름 붙임(데이터에 열 이름 없을 때 사용) . parsing . (뜻)parse -&gt; 분석하다 | . parse_무언가() : 문자형 벡터를 입력으로 하여 논리형, 정수형 또는 날짜형과 같은 좀 더 특수화된 벡터를 반환 . - parsing 실패 . 실패하면 경고문과 함께 NA로 표기 이 경우 problems()사용하면 문제점 알려줌 . x &lt;- parse_integer(c(&quot;123&quot;,&quot;345&quot;,&quot;abc&quot;,&quot;123.45&quot;)) . Warning message: “2 parsing failures. row col expected actual 3 -- no trailing characters abc 4 -- no trailing characters 123.45 ” . x . &lt;ol class=list-inline&gt;123 | 345 | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; problems(x) . A tibble: 2 × 4 rowcolexpectedactual . &lt;int&gt;&lt;int&gt;&lt;chr&gt;&lt;chr&gt; . 3 | NA | no trailing characters | abc | . 4 | NA | no trailing characters | 123.45 | . parse 종류 . parse_logical :논리형 parse_integer : 정수형 parse_double : 엄격한 수치형(★★★) parse_number : 유연한 수치형(★★) -&gt; 각자 다른 방식의 숫자 표현을 써버리기에 parse_character : 문자형 -&gt; 단순하지만 문자 인코딩에서 중요 parse_factor : 팩터형(R이 미리 정해지고 알려진 값으로 범주형 변수를 나타내기 위해 사용하는 데이터 구조) parse_datetime : 날짜/시각(★★★★) -&gt; 날짜를 쓰는 방법은 다양하기에 이들이 제일 복잡 parse_date : 날짜/시각(★★★★) parse_time : 날짜/시각(★★★★) . &#49707;&#51088; parsing . 숫자 파싱이 문제가 되는 3가지 1) 소수점 구별기호 ex) . or , 2) 단위 ex) $ % 3) 간혹 읽기 편하라고 &#39; &#39; 사용 . - 첫 번째 문제 해결 지역에 따라 파싱 옵션을 지정하는 객체인 locale사용 변경이 필요할 경우 새로운 locale을 생성하고 decimal_mark인수를 설정하여 기본값인 .을 다른 값으로 재정의 . parse_double(&quot;1.23&quot;) . 1.23 - 변경 예시 . parse_double(&quot;1,23&quot;, locale = locale(decimal_mark = &quot;,&quot;)) . 1.23 -두 번째 문제 해결 parse_number는 숫자 앞뒤의 비수치 문자(non-numeric character)를 모두 무시 통화 및 백분율에 특히 유용하고 텍스트에 포함된 숫자를 추출하는 데도 효과적 . parse_number(&quot;$100&quot;) . 100 parse_number(&quot;20%&quot;) . 20 - 비수치 문자 무시 예 . parse_number(&quot;It cost $123.45&quot;) . 123.45 - 미국식 처리법 . parse_number(&quot;$123,456,789&quot;) . 123456789 - 유럽식 처리법 . parse_number( &quot;123.456.789&quot;, locale = locale(grouping_mark = &quot;.&quot;)) . 123456789 - factor형 처리 R은 팩터형을 사용하기에, 가질 수 있는 값을 미리 알고 있는 범주형 변수를 나타낸다 . fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;) parse_factor(c(&quot;apple&quot;, &quot;banana&quot;, &quot;bananana&quot;), levels = fruit) . Warning message: “1 parsing failure. row col expected actual 3 -- value in level set bananana ” . &lt;ol class=list-inline&gt;apple | banana | &lt;NA&gt; | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt;&#39;apple&#39; | &#39;banana&#39; | &lt;/ol&gt; &#45216;&#51676; parsing . parse_datetime(&quot;2010-10-01T2010&quot;) . [1] &#34;2010-10-01 20:10:00 UTC&#34; . parse_datetime(&quot;20101010&quot;) . [1] &#34;2010-10-10 UTC&#34; . parse_date(&quot;2010-10-01&quot;) . 2010-10-01 library(&#39;hms&#39;)# 시간 데이터 다루는 패키지 . parse_time(&quot;20:10:01&quot;) . 20:10:01 . parse_time(&quot;01:10 am&quot;) . 01:10:00 . 위의 예시들로 주어진 데이터를 처리하지 못한다면 나만의 format을 만들어 사용가능 연 %Y(4 자리) %y(2 자리, 00-69 -&gt; 2000-2069, 70-99 -&gt; 1970-1999) 월 %m(2 자리) %b(&quot;jan&quot;과 같이 축약된 명칭) %B(전체 명칭, &quot;January&quot;) 일 %d(2 자리) %e(선택적 선행 공백) 시간 %H(0-23 시간 형식) %I(0-12, %p와 함께 사용해야 함) %p(a.m/p.m표시) %M(분) %S(정수 초) %OS(실수 초) 숫자가 아닌 문자 %.(숫자가 아닌 문자 하나를 건너뛴다) %*(숫자가 아닌 문자 모두를 건너뛴다) . - 시간 데이터 처리 예시 . parse_date(&quot;01/02/15&quot;, &quot;%m/%d/%y&quot;) . 2015-01-02 parse_date(&quot;01/02/15&quot;, &quot;%d/%m/%y&quot;) . 2015-02-01 parse_date(&quot;01/02/15&quot;, &quot;%y/%m/%d&quot;) . 2001-02-15",
            "url": "https://jjyun98.github.io/main/2022/07/22/_tibble_%ED%95%99%EC%8A%B5.html",
            "relUrl": "/2022/07/22/_tibble_%ED%95%99%EC%8A%B5.html",
            "date": " • Jul 22, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jjyun98.github.io/main/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jjyun98.github.io/main/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}